{"ast":null,"code":"/**\n * react-router v7.9.5\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { ENABLE_DEV_WARNINGS, ErrorResponseImpl, FrameworkContext, NO_BODY_STATUS_CODES, Outlet, RSCRouterContext, RemixErrorBoundary, RouterContextProvider, RouterProvider, SINGLE_FETCH_REDIRECT_STATUS, SingleFetchRedirectSymbol, StaticRouterProvider, StreamTransfer, convertRoutesToDataRoutes, createMemoryRouter, createServerRoutes, createStaticHandler, createStaticRouter, decodeViaTurboStream, encode, escapeHtml, getManifestPath, getStaticContextFromError, instrumentHandler, isDataWithResponseInit, isRedirectResponse, isRedirectStatusCode, isResponse, isRouteErrorResponse, matchRoutes, redirect, redirectDocument, replace, shouldHydrateRouteLoader, stripBasename, useRouteError, warnOnce, withComponentProps, withErrorBoundaryProps, withHydrateFallbackProps } from \"./chunk-UIGDSWPH.mjs\";\n\n// lib/dom/ssr/server.tsx\nimport * as React from \"react\";\nfunction ServerRouter({\n  context,\n  url,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let {\n    manifest,\n    routeModules,\n    criticalCss,\n    serverHandoffString\n  } = context;\n  let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    if (route && manifestRoute && shouldHydrateRouteLoader(routeId, route.clientLoader, manifestRoute.hasLoader, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      delete context.staticHandlerContext.loaderData[routeId];\n    }\n  }\n  let router = createStaticRouter(routes, context.staticHandlerContext);\n  return /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(FrameworkContext.Provider, {\n    value: {\n      manifest,\n      routeModules,\n      criticalCss,\n      serverHandoffString,\n      future: context.future,\n      ssr: context.ssr,\n      isSpaMode: context.isSpaMode,\n      routeDiscovery: context.routeDiscovery,\n      serializeError: context.serializeError,\n      renderMeta: context.renderMeta\n    }\n  }, /* @__PURE__ */React.createElement(RemixErrorBoundary, {\n    location: router.state.location\n  }, /* @__PURE__ */React.createElement(StaticRouterProvider, {\n    router,\n    context: context.staticHandlerContext,\n    hydrate: false\n  }))), context.serverHandoffStream ? /* @__PURE__ */React.createElement(React.Suspense, null, /* @__PURE__ */React.createElement(StreamTransfer, {\n    context,\n    identifier: 0,\n    reader: context.serverHandoffStream.getReader(),\n    textDecoder: new TextDecoder(),\n    nonce\n  })) : null);\n}\n\n// lib/dom/ssr/routes-test-stub.tsx\nimport * as React2 from \"react\";\nfunction createRoutesStub(routes, _context) {\n  return function RoutesTestStub({\n    initialEntries,\n    initialIndex,\n    hydrationData,\n    future\n  }) {\n    let routerRef = React2.useRef();\n    let frameworkContextRef = React2.useRef();\n    if (routerRef.current == null) {\n      frameworkContextRef.current = {\n        future: {\n          unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n          v8_middleware: future?.v8_middleware === true\n        },\n        manifest: {\n          routes: {},\n          entry: {\n            imports: [],\n            module: \"\"\n          },\n          url: \"\",\n          version: \"\"\n        },\n        routeModules: {},\n        ssr: false,\n        isSpaMode: false,\n        routeDiscovery: {\n          mode: \"lazy\",\n          manifestPath: \"/__manifest\"\n        }\n      };\n      let patched = processRoutes(\n      // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n      // types compared to `AgnosticRouteObject`\n      convertRoutesToDataRoutes(routes, r => r), _context !== void 0 ? _context : future?.v8_middleware ? new RouterContextProvider() : {}, frameworkContextRef.current.manifest, frameworkContextRef.current.routeModules);\n      routerRef.current = createMemoryRouter(patched, {\n        initialEntries,\n        initialIndex,\n        hydrationData\n      });\n    }\n    return /* @__PURE__ */React2.createElement(FrameworkContext.Provider, {\n      value: frameworkContextRef.current\n    }, /* @__PURE__ */React2.createElement(RouterProvider, {\n      router: routerRef.current\n    }));\n  };\n}\nfunction processRoutes(routes, context, manifest, routeModules, parentId) {\n  return routes.map(route => {\n    if (!route.id) {\n      throw new Error(\"Expected a route.id in react-router processRoutes() function\");\n    }\n    let newRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      Component: route.Component ? withComponentProps(route.Component) : void 0,\n      HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n      ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n      action: route.action ? args => route.action({\n        ...args,\n        context\n      }) : void 0,\n      loader: route.loader ? args => route.loader({\n        ...args,\n        context\n      }) : void 0,\n      middleware: route.middleware ? route.middleware.map(mw => (...args) => mw({\n        ...args[0],\n        context\n      }, args[1])) : void 0,\n      handle: route.handle,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    let entryRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      parentId,\n      hasAction: route.action != null,\n      hasLoader: route.loader != null,\n      // When testing routes, you should be stubbing loader/action/middleware,\n      // not trying to re-implement the full loader/clientLoader/SSR/hydration\n      // flow. That is better tested via E2E tests.\n      hasClientAction: false,\n      hasClientLoader: false,\n      hasClientMiddleware: false,\n      hasErrorBoundary: route.ErrorBoundary != null,\n      // any need for these?\n      module: \"build/stub-path-to-module.js\",\n      clientActionModule: void 0,\n      clientLoaderModule: void 0,\n      clientMiddlewareModule: void 0,\n      hydrateFallbackModule: void 0\n    };\n    manifest.routes[newRoute.id] = entryRoute;\n    routeModules[route.id] = {\n      default: newRoute.Component || Outlet,\n      ErrorBoundary: newRoute.ErrorBoundary || void 0,\n      handle: route.handle,\n      links: route.links,\n      meta: route.meta,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    if (route.children) {\n      newRoute.children = processRoutes(route.children, context, manifest, routeModules, newRoute.id);\n    }\n    return newRoute;\n  });\n}\n\n// lib/server-runtime/cookies.ts\nimport { parse, serialize } from \"cookie\";\n\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */new TextEncoder();\nvar sign = async (value, secret) => {\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"sign\"]);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n  return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret) => {\n  let index = cookie.lastIndexOf(\".\");\n  let value = cookie.slice(0, index);\n  let hash = cookie.slice(index + 1);\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"verify\"]);\n  try {\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n  } catch (error) {\n    return false;\n  }\n};\nvar createKey = async (secret, usages) => crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n  name: \"HMAC\",\n  hash: \"SHA-256\"\n}, false, usages);\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {}) => {\n  let {\n    secrets = [],\n    ...options\n  } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = parse(cookieHeader, {\n        ...options,\n        ...parseOptions\n      });\n      if (name in cookies) {\n        let value = cookies[name];\n        if (typeof value === \"string\" && value !== \"\") {\n          let decoded = await decodeCookieValue(value, secrets);\n          return decoded;\n        } else {\n          return \"\";\n        }\n      } else {\n        return null;\n      }\n    },\n    async serialize(value, serializeOptions) {\n      return serialize(name, value === \"\" ? \"\" : await encodeCookieValue(value, secrets), {\n        ...options,\n        ...serializeOptions\n      });\n    }\n  };\n};\nvar isCookie = object => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    let route = manifest[routeId];\n    if (route) {\n      memo[routeId] = route.module;\n    }\n    return memo;\n  }, {});\n}\n\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */(ServerMode2 => {\n  ServerMode2[\"Development\"] = \"development\";\n  ServerMode2[\"Production\"] = \"production\";\n  ServerMode2[\"Test\"] = \"test\";\n  return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n  return value === \"development\" /* Development */ || value === \"production\" /* Production */ || value === \"test\" /* Test */;\n}\n\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== \"development\" /* Development */) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = void 0;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, {\n      [routeId]: sanitizeError(error, serverMode)\n    });\n  }, {});\n}\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...(sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n  let matches = matchRoutes(routes, pathname, basename);\n  if (!matches) return null;\n  return matches.map(match => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n  let result = await handler({\n    request: stripRoutesParam(stripIndexParam(args.request)),\n    params: args.params,\n    context: args.context,\n    unstable_pattern: args.unstable_pattern\n  });\n  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n    throw new Response(null, result.init);\n  }\n  return result;\n}\nfunction stripIndexParam(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_routes\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\n// lib/server-runtime/invariant.ts\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\");\n    throw new Error(message);\n  }\n}\n\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n  if (typeof process !== \"undefined\") {\n    try {\n      if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n        return request.headers.get(headerName);\n      }\n    } catch (e) {}\n  }\n  return null;\n}\n\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach(route => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map(route => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      middleware: route.module.middleware,\n      // Need to use RR's version in the param typed here to permit the optional\n      // context even though we know it'll always be provided in remix\n      loader: route.module.loader ? async args => {\n        let preRenderedData = getBuildTimeHeader(args.request, \"X-React-Router-Prerender-Data\");\n        if (preRenderedData != null) {\n          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n          invariant(encoded, \"Missing prerendered data for route\");\n          let uint8array = new TextEncoder().encode(encoded);\n          let stream = new ReadableStream({\n            start(controller) {\n              controller.enqueue(uint8array);\n              controller.close();\n            }\n          });\n          let decoded = await decodeViaTurboStream(stream, global);\n          let data2 = decoded.value;\n          if (data2 && SingleFetchRedirectSymbol in data2) {\n            let result = data2[SingleFetchRedirectSymbol];\n            let init = {\n              status: result.status\n            };\n            if (result.reload) {\n              throw redirectDocument(result.redirect, init);\n            } else if (result.replace) {\n              throw replace(result.redirect, init);\n            } else {\n              throw redirect(result.redirect, init);\n            }\n          } else {\n            invariant(data2 && route.id in data2, \"Unable to decode prerendered data\");\n            let result = data2[route.id];\n            invariant(\"data\" in result, \"Unable to process prerendered data\");\n            return result.data;\n          }\n        }\n        let val = await callRouteHandler(route.module.loader, args);\n        return val;\n      } : void 0,\n      action: route.module.action ? args => callRouteHandler(route.module.action, args) : void 0,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),\n      ...commonRoute\n    };\n  });\n}\n\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n  return escapeHtml(JSON.stringify(serverHandoff));\n}\n\n// lib/server-runtime/headers.ts\nimport { splitCookiesString } from \"set-cookie-parser\";\nfunction getDocumentHeaders(context, build) {\n  return getDocumentHeadersImpl(context, m => {\n    let route = build.routes[m.route.id];\n    invariant(route, `Route with id \"${m.route.id}\" not found in build`);\n    return route.module.headers;\n  });\n}\nfunction getDocumentHeadersImpl(context, getRouteHeadersFn, _defaultHeaders) {\n  let boundaryIdx = context.errors ? context.matches.findIndex(m => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    let {\n      actionHeaders,\n      actionData,\n      loaderHeaders,\n      loaderData\n    } = context;\n    context.matches.slice(boundaryIdx).some(match => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  const defaultHeaders = new Headers(_defaultHeaders);\n  return matches.reduce((parentHeaders, match, idx) => {\n    let {\n      id\n    } = match.route;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n    let headersFn = getRouteHeadersFn(match);\n    if (headersFn == null) {\n      let headers2 = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers2);\n      }\n      prependCookies(actionHeaders, headers2);\n      prependCookies(loaderHeaders, headers2);\n      return headers2;\n    }\n    let headers = new Headers(typeof headersFn === \"function\" ? headersFn({\n      loaderHeaders,\n      parentHeaders,\n      actionHeaders,\n      errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n    }) : headersFn);\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers(defaultHeaders));\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = splitCookiesString(parentSetCookieString);\n    let childCookies = new Set(childHeaders.getSetCookie());\n    cookies.forEach(cookie => {\n      if (!childCookies.has(cookie)) {\n        childHeaders.append(\"Set-Cookie\", cookie);\n      }\n    });\n  }\n}\n\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */new Set([...NO_BODY_STATUS_CODES, 304]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...(request.body ? {\n        duplex: \"half\"\n      } : void 0)\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      skipRevalidation: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async query => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return isResponse(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: {\n        error\n      },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, {\n        status: context.statusCode,\n        headers\n      });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let singleFetchResult;\n    if (context.errors) {\n      singleFetchResult = {\n        error: Object.values(context.errors)[0]\n      };\n    } else {\n      singleFetchResult = {\n        data: Object.values(context.actionData || {})[0]\n      };\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: singleFetchResult,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n  let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      filterMatchesToLoad: m => !loadRouteIds || loadRouteIds.has(m.route.id),\n      skipLoaderErrorBubbling: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async query => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return isResponse(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: {\n        error\n      },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, {\n        status: context.statusCode,\n        headers\n      });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let results = {};\n    let loadedMatches = new Set(context.matches.filter(m => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map(m => m.route.id));\n    if (context.errors) {\n      for (let [id, error] of Object.entries(context.errors)) {\n        results[id] = {\n          error\n        };\n      }\n    }\n    for (let [id, data2] of Object.entries(context.loaderData)) {\n      if (!(id in results) && loadedMatches.has(id)) {\n        results[id] = {\n          data: data2\n        };\n      }\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: results,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, {\n  result,\n  headers,\n  status\n}) {\n  let resultHeaders = new Headers(headers);\n  resultHeaders.set(\"X-Remix-Response\", \"yes\");\n  if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n    return new Response(null, {\n      status,\n      headers: resultHeaders\n    });\n  }\n  resultHeaders.set(\"Content-Type\", \"text/x-script\");\n  resultHeaders.delete(\"Content-Length\");\n  return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {\n    status: status || 200,\n    headers: resultHeaders\n  });\n}\nfunction generateSingleFetchRedirectResponse(redirectResponse, request, build, serverMode) {\n  let redirect2 = getSingleFetchRedirect(redirectResponse.status, redirectResponse.headers, build.basename);\n  let headers = new Headers(redirectResponse.headers);\n  headers.delete(\"Location\");\n  headers.set(\"Content-Type\", \"text/x-script\");\n  return generateSingleFetchResponse(request, build, serverMode, {\n    result: request.method === \"GET\" ? {\n      [SingleFetchRedirectSymbol]: redirect2\n    } : redirect2,\n    headers,\n    status: SINGLE_FETCH_REDIRECT_STATUS\n  });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n  let redirect2 = headers.get(\"Location\");\n  if (basename) {\n    redirect2 = stripBasename(redirect2, basename) || redirect2;\n  }\n  return {\n    redirect: redirect2,\n    status,\n    revalidate:\n    // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n    // detail of ?_data requests as our way to tell the front end to revalidate when\n    // we didn't have a response body to include that information in.\n    // With single fetch, we tell the front end via this revalidate boolean field.\n    // However, we're respecting it for now because it may be something folks have\n    // used in their own responses\n    // TODO(v3): Consider removing or making this official public API\n    headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n    reload: headers.has(\"X-Remix-Reload-Document\"),\n    replace: headers.has(\"X-Remix-Replace\")\n  };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  let timeoutId = setTimeout(() => controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return encode(data2, {\n    signal: controller.signal,\n    plugins: [value => {\n      if (value instanceof Error) {\n        let {\n          name,\n          message,\n          stack\n        } = serverMode === \"production\" /* Production */ ? sanitizeError(value, serverMode) : value;\n        return [\"SanitizedError\", name, message, stack];\n      }\n      if (value instanceof ErrorResponseImpl) {\n        let {\n          data: data3,\n          status,\n          statusText\n        } = value;\n        return [\"ErrorResponse\", data3, status, statusText];\n      }\n      if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n        return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n      }\n    }],\n    postPlugins: [value => {\n      if (!value) return;\n      if (typeof value !== \"object\") return;\n      return [\"SingleFetchClassInstance\", Object.fromEntries(Object.entries(value))];\n    }, () => [\"SingleFetchFallback\"]]\n  });\n}\n\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n  let routes = createRoutes(build.routes);\n  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */;\n  let staticHandler = createStaticHandler(dataRoutes, {\n    basename: build.basename,\n    unstable_instrumentations: build.entry.module.unstable_instrumentations\n  });\n  let errorHandler = build.entry.module.handleError || ((error, {\n    request\n  }) => {\n    if (serverMode !== \"test\" /* Test */ && !request.signal.aborted) {\n      console.error(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      isRouteErrorResponse(error) && error.error ? error.error : error);\n    }\n  });\n  let requestHandler = async (request, initialContext) => {\n    let params = {};\n    let loadContext;\n    let handleError = error => {\n      if (mode === \"development\" /* Development */) {\n        getDevServerHooks()?.processRequestError?.(error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params,\n        request\n      });\n    };\n    if (build.future.v8_middleware) {\n      if (initialContext && !(initialContext instanceof RouterContextProvider)) {\n        let error = new Error(\"Invalid `context` value provided to `handleRequest`. When middleware is enabled you must return an instance of `RouterContextProvider` from your `getLoadContext` function.\");\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n      }\n      loadContext = initialContext || new RouterContextProvider();\n    } else {\n      loadContext = initialContext || {};\n    }\n    let url = new URL(request.url);\n    let normalizedBasename = build.basename || \"/\";\n    let normalizedPath = url.pathname;\n    if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n      normalizedPath = normalizedBasename;\n    } else if (normalizedPath.endsWith(\".data\")) {\n      normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n    }\n    if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n      normalizedPath = normalizedPath.slice(0, -1);\n    }\n    let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n    if (!build.ssr) {\n      let decodedPath = decodeURI(normalizedPath);\n      if (normalizedBasename !== \"/\") {\n        let strippedPath = stripBasename(decodedPath, normalizedBasename);\n        if (strippedPath == null) {\n          errorHandler(new ErrorResponseImpl(404, \"Not Found\", `Refusing to prerender the \\`${decodedPath}\\` path because it does not start with the basename \\`${normalizedBasename}\\``), {\n            context: loadContext,\n            params,\n            request\n          });\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        }\n        decodedPath = strippedPath;\n      }\n      if (build.prerender.length === 0) {\n        isSpaMode = true;\n      } else if (!build.prerender.includes(decodedPath) && !build.prerender.includes(decodedPath + \"/\")) {\n        if (url.pathname.endsWith(\".data\")) {\n          errorHandler(new ErrorResponseImpl(404, \"Not Found\", `Refusing to SSR the path \\`${decodedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`), {\n            context: loadContext,\n            params,\n            request\n          });\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        } else {\n          isSpaMode = true;\n        }\n      }\n    }\n    let manifestUrl = getManifestPath(build.routeDiscovery.manifestPath, normalizedBasename);\n    if (url.pathname === manifestUrl) {\n      try {\n        let res = await handleManifestRequest(build, routes, url);\n        return res;\n      } catch (e) {\n        handleError(e);\n        return new Response(\"Unknown Server Error\", {\n          status: 500\n        });\n      }\n    }\n    let matches = matchServerRoutes(routes, normalizedPath, build.basename);\n    if (matches && matches.length > 0) {\n      Object.assign(params, matches[0].params);\n    }\n    let response;\n    if (url.pathname.endsWith(\".data\")) {\n      let handlerUrl = new URL(request.url);\n      handlerUrl.pathname = normalizedPath;\n      let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, build.basename);\n      response = await handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError);\n      if (isRedirectResponse(response)) {\n        response = generateSingleFetchRedirectResponse(response, request, build, serverMode);\n      }\n      if (build.entry.module.handleDataRequest) {\n        response = await build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: singleFetchMatches ? singleFetchMatches[0].params : {},\n          request\n        });\n        if (isRedirectResponse(response)) {\n          response = generateSingleFetchRedirectResponse(response, request, build, serverMode);\n        }\n      }\n    } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequest(serverMode, build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);\n    } else {\n      let {\n        pathname\n      } = url;\n      let criticalCss = void 0;\n      if (build.unstable_getCriticalCss) {\n        criticalCss = await build.unstable_getCriticalCss({\n          pathname\n        });\n      } else if (mode === \"development\" /* Development */ && getDevServerHooks()?.getCriticalCss) {\n        criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n      }\n      response = await handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss);\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n  if (build.entry.module.unstable_instrumentations) {\n    requestHandler = instrumentHandler(requestHandler, build.entry.module.unstable_instrumentations.map(i => i.handler).filter(Boolean));\n  }\n  return {\n    routes,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler,\n    requestHandler\n  };\n}\nvar createRequestHandler = (build, mode) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  let _requestHandler;\n  return async function requestHandler(request, initialContext) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n      _requestHandler = derived.requestHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler || !_requestHandler) {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n      _requestHandler = derived.requestHandler;\n    }\n    return _requestHandler(request, initialContext);\n  };\n};\nasync function handleManifestRequest(build, routes, url) {\n  if (build.assets.version !== url.searchParams.get(\"version\")) {\n    return new Response(null, {\n      status: 204,\n      headers: {\n        \"X-Remix-Reload-Document\": \"true\"\n      }\n    });\n  }\n  let patches = {};\n  if (url.searchParams.has(\"paths\")) {\n    let paths = /* @__PURE__ */new Set();\n    let pathParam = url.searchParams.get(\"paths\") || \"\";\n    let requestedPaths = pathParam.split(\",\").filter(Boolean);\n    requestedPaths.forEach(path => {\n      if (!path.startsWith(\"/\")) {\n        path = `/${path}`;\n      }\n      let segments = path.split(\"/\").slice(1);\n      segments.forEach((_, i) => {\n        let partialPath = segments.slice(0, i + 1).join(\"/\");\n        paths.add(`/${partialPath}`);\n      });\n    });\n    for (let path of paths) {\n      let matches = matchServerRoutes(routes, path, build.basename);\n      if (matches) {\n        for (let match of matches) {\n          let routeId = match.route.id;\n          let route = build.assets.routes[routeId];\n          if (route) {\n            patches[routeId] = route;\n          }\n        }\n      }\n    }\n    return Response.json(patches, {\n      headers: {\n        \"Cache-Control\": \"public, max-age=31536000, immutable\"\n      }\n    });\n  }\n  return new Response(\"Invalid Request\", {\n    status: 400\n  });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let response = request.method !== \"GET\" ? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);\n  return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n  try {\n    let result = await staticHandler.query(request, {\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async query => {\n        try {\n          let innerResult = await query(request);\n          if (!isResponse(innerResult)) {\n            innerResult = await renderHtml(innerResult, isSpaMode);\n          }\n          return innerResult;\n        } catch (error) {\n          handleError(error);\n          return new Response(null, {\n            status: 500\n          });\n        }\n      } : void 0\n    });\n    if (!isResponse(result)) {\n      result = await renderHtml(result, isSpaMode);\n    }\n    return result;\n  } catch (error) {\n    handleError(error);\n    return new Response(null, {\n      status: 500\n    });\n  }\n  async function renderHtml(context, isSpaMode2) {\n    let headers = getDocumentHeaders(context, build);\n    if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n      return new Response(null, {\n        status: context.statusCode,\n        headers\n      });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach(err => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let state = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors, serverMode)\n    };\n    let baseServerHandoff = {\n      basename: build.basename,\n      future: build.future,\n      routeDiscovery: build.routeDiscovery,\n      ssr: build.ssr,\n      isSpaMode: isSpaMode2\n    };\n    let entryContext = {\n      manifest: build.assets,\n      routeModules: createEntryRouteModules(build.routes),\n      staticHandlerContext: context,\n      criticalCss,\n      serverHandoffString: createServerHandoffString({\n        ...baseServerHandoff,\n        criticalCss\n      }),\n      serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),\n      renderMeta: {},\n      future: build.future,\n      ssr: build.ssr,\n      routeDiscovery: build.routeDiscovery,\n      isSpaMode: isSpaMode2,\n      serializeError: err => serializeError(err, serverMode)\n    };\n    let handleDocumentRequestFunction = build.entry.module.default;\n    try {\n      return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n    } catch (error) {\n      handleError(error);\n      let errorForSecondRender = error;\n      if (isResponse(error)) {\n        try {\n          let data2 = await unwrapResponse(error);\n          errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);\n        } catch (e) {}\n      }\n      context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);\n      if (context.errors) {\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let state2 = {\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: serializeErrors(context.errors, serverMode)\n      };\n      entryContext = {\n        ...entryContext,\n        staticHandlerContext: context,\n        serverHandoffString: createServerHandoffString(baseServerHandoff),\n        serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),\n        renderMeta: {}\n      };\n      try {\n        return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n      } catch (error2) {\n        handleError(error2);\n        return returnLastResortErrorResponse(error2, serverMode);\n      }\n    }\n  }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let result = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async queryRoute => {\n        try {\n          let innerResult = await queryRoute(request);\n          return handleQueryRouteResult(innerResult);\n        } catch (error) {\n          return handleQueryRouteError(error);\n        }\n      } : void 0\n    });\n    return handleQueryRouteResult(result);\n  } catch (error) {\n    return handleQueryRouteError(error);\n  }\n  function handleQueryRouteResult(result) {\n    if (isResponse(result)) {\n      return result;\n    }\n    if (typeof result === \"string\") {\n      return new Response(result);\n    }\n    return Response.json(result);\n  }\n  function handleQueryRouteError(error) {\n    if (isResponse(error)) {\n      return error;\n    }\n    if (isRouteErrorResponse(error)) {\n      handleError(error);\n      return errorResponseToJson(error, serverMode);\n    }\n    if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n      let newError = new Error(\"Expected a Response to be returned from resource route handler\");\n      handleError(newError);\n      return returnLastResortErrorResponse(newError, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return Response.json(serializeError(\n  // @ts-expect-error This is \"private\" from users but intended for internal use\n  errorResponse.error || new Error(\"Unexpected Server Error\"), serverMode), {\n    status: errorResponse.status,\n    statusText: errorResponse.statusText\n  });\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== \"production\" /* Production */) {\n    message += `\n\n${String(error)}`;\n  }\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\nfunction unwrapResponse(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nvar isSession = object => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && (await cookie.parse(cookieHeader, options));\n      let data2 = id && (await readData(id));\n      return createSession(data2 || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let {\n        id,\n        data: data2\n      } = session;\n      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data2, expires);\n      } else {\n        id = await createData(data2, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */new Date(0)\n      });\n    }\n  };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`);\n}\n\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({\n  cookie: cookieArg\n} = {}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */new Date(0)\n      });\n    }\n  };\n}\n\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({\n  cookie\n} = {}) {\n  let map = /* @__PURE__ */new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data2, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, {\n        data: data2,\n        expires\n      });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let {\n          data: data2,\n          expires\n        } = map.get(id);\n        if (!expires || expires > /* @__PURE__ */new Date()) {\n          return data2;\n        }\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data2, expires) {\n      map.set(id, {\n        data: data2,\n        expires\n      });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n}\n\n// lib/href.ts\nfunction href(path, ...args) {\n  let params = args[0];\n  let result = path.replace(/\\/*\\*?$/, \"\").replace(/\\/:([\\w-]+)(\\?)?/g,\n  // same regex as in .\\router\\utils.ts: compilePath().\n  (_, param, questionMark) => {\n    const isRequired = questionMark === void 0;\n    const value = params ? params[param] : void 0;\n    if (isRequired && value === void 0) {\n      throw new Error(`Path '${path}' requires param '${param}' but it was not provided`);\n    }\n    return value === void 0 ? \"\" : \"/\" + value;\n  });\n  if (path.endsWith(\"*\")) {\n    const value = params ? params[\"*\"] : void 0;\n    if (value !== void 0) {\n      result += \"/\" + value;\n    }\n  }\n  return result || \"/\";\n}\n\n// lib/rsc/server.ssr.tsx\nimport * as React4 from \"react\";\n\n// lib/rsc/html-stream/server.ts\nvar encoder2 = new TextEncoder();\nvar trailer = \"</body></html>\";\nfunction injectRSCPayload(rscStream) {\n  let decoder = new TextDecoder();\n  let resolveFlightDataPromise;\n  let flightDataPromise = new Promise(resolve => resolveFlightDataPromise = resolve);\n  let startedRSC = false;\n  let buffered = [];\n  let timeout = null;\n  function flushBufferedChunks(controller) {\n    for (let chunk of buffered) {\n      let buf = decoder.decode(chunk, {\n        stream: true\n      });\n      if (buf.endsWith(trailer)) {\n        buf = buf.slice(0, -trailer.length);\n      }\n      controller.enqueue(encoder2.encode(buf));\n    }\n    buffered.length = 0;\n    timeout = null;\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      buffered.push(chunk);\n      if (timeout) {\n        return;\n      }\n      timeout = setTimeout(async () => {\n        flushBufferedChunks(controller);\n        if (!startedRSC) {\n          startedRSC = true;\n          writeRSCStream(rscStream, controller).catch(err => controller.error(err)).then(resolveFlightDataPromise);\n        }\n      }, 0);\n    },\n    async flush(controller) {\n      await flightDataPromise;\n      if (timeout) {\n        clearTimeout(timeout);\n        flushBufferedChunks(controller);\n      }\n      controller.enqueue(encoder2.encode(\"</body></html>\"));\n    }\n  });\n}\nasync function writeRSCStream(rscStream, controller) {\n  let decoder = new TextDecoder(\"utf-8\", {\n    fatal: true\n  });\n  const reader = rscStream.getReader();\n  try {\n    let read;\n    while ((read = await reader.read()) && !read.done) {\n      const chunk = read.value;\n      try {\n        writeChunk(JSON.stringify(decoder.decode(chunk, {\n          stream: true\n        })), controller);\n      } catch (err) {\n        let base64 = JSON.stringify(btoa(String.fromCodePoint(...chunk)));\n        writeChunk(`Uint8Array.from(atob(${base64}), m => m.codePointAt(0))`, controller);\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  let remaining = decoder.decode();\n  if (remaining.length) {\n    writeChunk(JSON.stringify(remaining), controller);\n  }\n}\nfunction writeChunk(chunk, controller) {\n  controller.enqueue(encoder2.encode(`<script>${escapeScript(`(self.__FLIGHT_DATA||=[]).push(${chunk})`)}</script>`));\n}\nfunction escapeScript(script) {\n  return script.replace(/<!--/g, \"<\\\\!--\").replace(/<\\/(script)/gi, \"</\\\\$1\");\n}\n\n// lib/rsc/errorBoundaries.tsx\nimport React3 from \"react\";\nvar RSCRouterGlobalErrorBoundary = class extends React3.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null,\n      location: props.location\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return {\n        error: null,\n        location: props.location\n      };\n    }\n    return {\n      error: state.error,\n      location: state.location\n    };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */React3.createElement(RSCDefaultRootErrorBoundaryImpl, {\n        error: this.state.error,\n        renderAppShell: true\n      });\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction ErrorWrapper({\n  renderAppShell,\n  title,\n  children\n}) {\n  if (!renderAppShell) {\n    return children;\n  }\n  return /* @__PURE__ */React3.createElement(\"html\", {\n    lang: \"en\"\n  }, /* @__PURE__ */React3.createElement(\"head\", null, /* @__PURE__ */React3.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /* @__PURE__ */React3.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /* @__PURE__ */React3.createElement(\"title\", null, title)), /* @__PURE__ */React3.createElement(\"body\", null, /* @__PURE__ */React3.createElement(\"main\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, children)));\n}\nfunction RSCDefaultRootErrorBoundaryImpl({\n  error,\n  renderAppShell\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */React3.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n    }\n  });\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */React3.createElement(ErrorWrapper, {\n      renderAppShell,\n      title: \"Unhandled Thrown Response!\"\n    }, /* @__PURE__ */React3.createElement(\"h1\", {\n      style: {\n        fontSize: \"24px\"\n      }\n    }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */React3.createElement(ErrorWrapper, {\n    renderAppShell,\n    title: \"Application Error!\"\n  }, /* @__PURE__ */React3.createElement(\"h1\", {\n    style: {\n      fontSize: \"24px\"\n    }\n  }, \"Application Error\"), /* @__PURE__ */React3.createElement(\"pre\", {\n    style: {\n      padding: \"2rem\",\n      background: \"hsla(10, 50%, 50%, 0.1)\",\n      color: \"red\",\n      overflow: \"auto\"\n    }\n  }, errorInstance.stack), heyDeveloper);\n}\nfunction RSCDefaultRootErrorBoundary({\n  hasRootLayout\n}) {\n  let error = useRouteError();\n  if (hasRootLayout === void 0) {\n    throw new Error(\"Missing 'hasRootLayout' prop\");\n  }\n  return /* @__PURE__ */React3.createElement(RSCDefaultRootErrorBoundaryImpl, {\n    renderAppShell: !hasRootLayout,\n    error\n  });\n}\n\n// lib/rsc/route-modules.ts\nfunction createRSCRouteModules(payload) {\n  const routeModules = {};\n  for (const match of payload.matches) {\n    populateRSCRouteModules(routeModules, match);\n  }\n  return routeModules;\n}\nfunction populateRSCRouteModules(routeModules, matches) {\n  matches = Array.isArray(matches) ? matches : [matches];\n  for (const match of matches) {\n    routeModules[match.id] = {\n      links: match.links,\n      meta: match.meta,\n      default: noopComponent\n    };\n  }\n}\nvar noopComponent = () => null;\n\n// lib/rsc/server.ssr.tsx\nvar REACT_USE = \"use\";\nvar useImpl = React4[REACT_USE];\nfunction useSafe(promise) {\n  if (useImpl) {\n    return useImpl(promise);\n  }\n  throw new Error(\"React Router v7 requires React 19+ for RSC features.\");\n}\nasync function routeRSCServerRequest({\n  request,\n  fetchServer,\n  createFromReadableStream,\n  renderHTML,\n  hydrate = true\n}) {\n  const url = new URL(request.url);\n  const isDataRequest = isReactServerRequest(url);\n  const respondWithRSCPayload = isDataRequest || isManifestRequest(url) || request.headers.has(\"rsc-action-id\");\n  const serverResponse = await fetchServer(request);\n  if (respondWithRSCPayload || serverResponse.headers.get(\"React-Router-Resource\") === \"true\") {\n    return serverResponse;\n  }\n  if (!serverResponse.body) {\n    throw new Error(\"Missing body in server response\");\n  }\n  const detectRedirectResponse = serverResponse.clone();\n  let serverResponseB = null;\n  if (hydrate) {\n    serverResponseB = serverResponse.clone();\n  }\n  const body = serverResponse.body;\n  let buffer;\n  let streamControllers = [];\n  const createStream = () => {\n    if (!buffer) {\n      buffer = [];\n      return body.pipeThrough(new TransformStream({\n        transform(chunk, controller) {\n          buffer.push(chunk);\n          controller.enqueue(chunk);\n          streamControllers.forEach(c => c.enqueue(chunk));\n        },\n        flush() {\n          streamControllers.forEach(c => c.close());\n          streamControllers = [];\n        }\n      }));\n    }\n    return new ReadableStream({\n      start(controller) {\n        buffer.forEach(chunk => controller.enqueue(chunk));\n        streamControllers.push(controller);\n      }\n    });\n  };\n  let deepestRenderedBoundaryId = null;\n  const getPayload = () => {\n    const payloadPromise = Promise.resolve(createFromReadableStream(createStream()));\n    return Object.defineProperties(payloadPromise, {\n      _deepestRenderedBoundaryId: {\n        get() {\n          return deepestRenderedBoundaryId;\n        },\n        set(boundaryId) {\n          deepestRenderedBoundaryId = boundaryId;\n        }\n      },\n      formState: {\n        get() {\n          return payloadPromise.then(payload => payload.type === \"render\" ? payload.formState : void 0);\n        }\n      }\n    });\n  };\n  try {\n    if (!detectRedirectResponse.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const payload = await createFromReadableStream(detectRedirectResponse.body);\n    if (serverResponse.status === SINGLE_FETCH_REDIRECT_STATUS && payload.type === \"redirect\") {\n      const headers2 = new Headers(serverResponse.headers);\n      headers2.delete(\"Content-Encoding\");\n      headers2.delete(\"Content-Length\");\n      headers2.delete(\"Content-Type\");\n      headers2.delete(\"X-Remix-Response\");\n      headers2.set(\"Location\", payload.location);\n      return new Response(serverResponseB?.body || \"\", {\n        headers: headers2,\n        status: payload.status,\n        statusText: serverResponse.statusText\n      });\n    }\n    const html = await renderHTML(getPayload);\n    const headers = new Headers(serverResponse.headers);\n    headers.set(\"Content-Type\", \"text/html; charset=utf-8\");\n    if (!hydrate) {\n      return new Response(html, {\n        status: serverResponse.status,\n        headers\n      });\n    }\n    if (!serverResponseB?.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n    return new Response(body2, {\n      status: serverResponse.status,\n      headers\n    });\n  } catch (reason) {\n    if (reason instanceof Response) {\n      return reason;\n    }\n    try {\n      const status = isRouteErrorResponse(reason) ? reason.status : 500;\n      const html = await renderHTML(() => {\n        const decoded = Promise.resolve(createFromReadableStream(createStream()));\n        const payloadPromise = decoded.then(payload => Object.assign(payload, {\n          status,\n          errors: deepestRenderedBoundaryId ? {\n            [deepestRenderedBoundaryId]: reason\n          } : {}\n        }));\n        return Object.defineProperties(payloadPromise, {\n          _deepestRenderedBoundaryId: {\n            get() {\n              return deepestRenderedBoundaryId;\n            },\n            set(boundaryId) {\n              deepestRenderedBoundaryId = boundaryId;\n            }\n          },\n          formState: {\n            get() {\n              return payloadPromise.then(payload => payload.type === \"render\" ? payload.formState : void 0);\n            }\n          }\n        });\n      });\n      const headers = new Headers(serverResponse.headers);\n      headers.set(\"Content-Type\", \"text/html\");\n      if (!hydrate) {\n        return new Response(html, {\n          status,\n          headers\n        });\n      }\n      if (!serverResponseB?.body) {\n        throw new Error(\"Failed to clone server response\");\n      }\n      const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n      return new Response(body2, {\n        status,\n        headers\n      });\n    } catch {}\n    throw reason;\n  }\n}\nfunction RSCStaticRouter({\n  getPayload\n}) {\n  const decoded = getPayload();\n  const payload = useSafe(decoded);\n  if (payload.type === \"redirect\") {\n    throw new Response(null, {\n      status: payload.status,\n      headers: {\n        Location: payload.location\n      }\n    });\n  }\n  if (payload.type !== \"render\") return null;\n  let patchedLoaderData = {\n    ...payload.loaderData\n  };\n  for (const match of payload.matches) {\n    if (shouldHydrateRouteLoader(match.id, match.clientLoader, match.hasLoader, false) && (match.hydrateFallbackElement || !match.hasLoader)) {\n      delete patchedLoaderData[match.id];\n    }\n  }\n  const context = {\n    get _deepestRenderedBoundaryId() {\n      return decoded._deepestRenderedBoundaryId ?? null;\n    },\n    set _deepestRenderedBoundaryId(boundaryId) {\n      decoded._deepestRenderedBoundaryId = boundaryId;\n    },\n    actionData: payload.actionData,\n    actionHeaders: {},\n    basename: payload.basename,\n    errors: payload.errors,\n    loaderData: patchedLoaderData,\n    loaderHeaders: {},\n    location: payload.location,\n    statusCode: 200,\n    matches: payload.matches.map(match => ({\n      params: match.params,\n      pathname: match.pathname,\n      pathnameBase: match.pathnameBase,\n      route: {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        handle: match.handle,\n        hasErrorBoundary: match.hasErrorBoundary,\n        loader: match.hasLoader || !!match.clientLoader,\n        index: match.index,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      }\n    }))\n  };\n  const router = createStaticRouter(payload.matches.reduceRight((previous, match) => {\n    const route = {\n      id: match.id,\n      action: match.hasAction || !!match.clientAction,\n      element: match.element,\n      errorElement: match.errorElement,\n      handle: match.handle,\n      hasErrorBoundary: !!match.errorElement,\n      hydrateFallbackElement: match.hydrateFallbackElement,\n      index: match.index,\n      loader: match.hasLoader || !!match.clientLoader,\n      path: match.path,\n      shouldRevalidate: match.shouldRevalidate\n    };\n    if (previous.length > 0) {\n      route.children = previous;\n    }\n    return [route];\n  }, []), context);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: {\n      mode: \"lazy\",\n      manifestPath: \"/__manifest\"\n    },\n    routeModules: createRSCRouteModules(payload)\n  };\n  return /* @__PURE__ */React4.createElement(RSCRouterContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React4.createElement(RSCRouterGlobalErrorBoundary, {\n    location: payload.location\n  }, /* @__PURE__ */React4.createElement(FrameworkContext.Provider, {\n    value: frameworkContext\n  }, /* @__PURE__ */React4.createElement(StaticRouterProvider, {\n    context,\n    router,\n    hydrate: false,\n    nonce: payload.nonce\n  }))));\n}\nfunction isReactServerRequest(url) {\n  return url.pathname.endsWith(\".rsc\");\n}\nfunction isManifestRequest(url) {\n  return url.pathname.endsWith(\".manifest\");\n}\n\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {}\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData({\n  state,\n  routes,\n  getRouteInfo,\n  location,\n  basename,\n  isSpaMode\n}) {\n  let hydrationData = {\n    ...state,\n    loaderData: {\n      ...state.loaderData\n    }\n  };\n  let initialMatches = matchRoutes(routes, location, basename);\n  if (initialMatches) {\n    for (let match of initialMatches) {\n      let routeId = match.route.id;\n      let routeInfo = getRouteInfo(routeId);\n      if (shouldHydrateRouteLoader(routeId, routeInfo.clientLoader, routeInfo.hasLoader, isSpaMode) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n        delete hydrationData.loaderData[routeId];\n      } else if (!routeInfo.hasLoader) {\n        hydrationData.loaderData[routeId] = null;\n      }\n    }\n  }\n  return hydrationData;\n}\nexport { ServerRouter, createRoutesStub, createCookie, isCookie, ServerMode, setDevServerHooks, createRequestHandler, createSession, isSession, createSessionStorage, createCookieSessionStorage, createMemorySessionStorage, href, RSCRouterGlobalErrorBoundary, RSCDefaultRootErrorBoundary, populateRSCRouteModules, routeRSCServerRequest, RSCStaticRouter, deserializeErrors, getHydrationData };","map":{"version":3,"names":["ENABLE_DEV_WARNINGS","ErrorResponseImpl","FrameworkContext","NO_BODY_STATUS_CODES","Outlet","RSCRouterContext","RemixErrorBoundary","RouterContextProvider","RouterProvider","SINGLE_FETCH_REDIRECT_STATUS","SingleFetchRedirectSymbol","StaticRouterProvider","StreamTransfer","convertRoutesToDataRoutes","createMemoryRouter","createServerRoutes","createStaticHandler","createStaticRouter","decodeViaTurboStream","encode","escapeHtml","getManifestPath","getStaticContextFromError","instrumentHandler","isDataWithResponseInit","isRedirectResponse","isRedirectStatusCode","isResponse","isRouteErrorResponse","matchRoutes","redirect","redirectDocument","replace","shouldHydrateRouteLoader","stripBasename","useRouteError","warnOnce","withComponentProps","withErrorBoundaryProps","withHydrateFallbackProps","React","ServerRouter","context","url","nonce","URL","manifest","routeModules","criticalCss","serverHandoffString","routes","future","isSpaMode","staticHandlerContext","loaderData","match","matches","routeId","route","id","manifestRoute","clientLoader","hasLoader","HydrateFallback","router","createElement","Fragment","Provider","value","ssr","routeDiscovery","serializeError","renderMeta","location","state","hydrate","serverHandoffStream","Suspense","identifier","reader","getReader","textDecoder","TextDecoder","React2","createRoutesStub","_context","RoutesTestStub","initialEntries","initialIndex","hydrationData","routerRef","useRef","frameworkContextRef","current","unstable_subResourceIntegrity","v8_middleware","entry","imports","module","version","mode","manifestPath","patched","processRoutes","r","parentId","map","Error","newRoute","path","index","Component","ErrorBoundary","action","args","loader","middleware","mw","handle","shouldRevalidate","entryRoute","hasAction","hasClientAction","hasClientLoader","hasClientMiddleware","hasErrorBoundary","clientActionModule","clientLoaderModule","clientMiddlewareModule","hydrateFallbackModule","default","links","meta","children","parse","serialize","encoder","TextEncoder","sign","secret","data2","key","createKey","signature","crypto","subtle","hash","btoa","String","fromCharCode","Uint8Array","unsign","cookie","lastIndexOf","slice","byteStringToUint8Array","atob","valid","verify","error","usages","importKey","name","byteString","array","length","i","charCodeAt","createCookie","cookieOptions","secrets","options","sameSite","warnOnceAboutExpiresCookie","expires","isSigned","maxAge","Date","now","cookieHeader","parseOptions","cookies","decoded","decodeCookieValue","serializeOptions","encodeCookieValue","isCookie","object","encoded","encodeData","unsignedValue","decodeData","myUnescape","encodeURIComponent","JSON","stringify","decodeURIComponent","myEscape","str","toString","result","chr","code","charAt","exec","hex","toUpperCase","part","parseInt","createEntryRouteModules","Object","keys","reduce","memo","ServerMode","ServerMode2","isServerMode","sanitizeError","serverMode","sanitized","stack","sanitizeErrors","errors","entries","acc","assign","message","serializeErrors","serialized","val","__type","__subType","matchServerRoutes","pathname","basename","params","callRouteHandler","handler","request","stripRoutesParam","stripIndexParam","unstable_pattern","init","status","Response","indexValues","searchParams","getAll","delete","indexValuesToKeep","indexValue","push","toKeep","append","method","body","headers","signal","duplex","Request","href","invariant","console","globalDevServerHooksKey","setDevServerHooks","devServerHooks","globalThis","getDevServerHooks","getBuildTimeHeader","headerName","process","env","IS_RR_BUILD_REQUEST","get","e","groupRoutesByParentId","values","forEach","createRoutes","routesByParentId","createStaticHandlerDataRoutes","commonRoute","preRenderedData","decodeURI","uint8array","stream","ReadableStream","start","controller","enqueue","close","global","reload","data","caseSensitive","createServerHandoffString","serverHandoff","splitCookiesString","getDocumentHeaders","build","getDocumentHeadersImpl","m","getRouteHeadersFn","_defaultHeaders","boundaryIdx","findIndex","errorHeaders","actionHeaders","actionData","loaderHeaders","some","hasOwnProperty","defaultHeaders","Headers","parentHeaders","idx","includeErrorHeaders","includeErrorCookies","headersFn","headers2","prependCookies","childHeaders","parentSetCookieString","childCookies","Set","getSetCookie","has","SERVER_NO_BODY_STATUS_CODES","singleFetchAction","staticHandler","handlerUrl","loadContext","handleError","handlerRequest","query","requestContext","skipLoaderErrorBubbling","skipRevalidation","generateMiddlewareResponse","innerResult","handleQueryResult","handleQueryError","staticContextToResponse","generateSingleFetchResponse","statusCode","err","singleFetchResult","singleFetchLoaders","routesParam","loadRouteIds","split","filterMatchesToLoad","results","loadedMatches","filter","resultHeaders","set","encodeViaTurboStream","streamTimeout","generateSingleFetchRedirectResponse","redirectResponse","redirect2","getSingleFetchRedirect","revalidate","requestSignal","AbortController","timeoutId","setTimeout","abort","addEventListener","clearTimeout","plugins","data3","statusText","postPlugins","fromEntries","derive","dataRoutes","unstable_instrumentations","errorHandler","aborted","requestHandler","initialContext","processRequestError","returnLastResortErrorResponse","normalizedBasename","normalizedPath","endsWith","decodedPath","strippedPath","prerender","includes","manifestUrl","res","handleManifestRequest","response","singleFetchMatches","handleSingleFetchRequest","handleDataRequest","handleResourceRequest","unstable_getCriticalCss","getCriticalCss","handleDocumentRequest","Boolean","createRequestHandler","_build","_requestHandler","derived","assets","patches","paths","pathParam","requestedPaths","startsWith","segments","_","partialPath","join","add","json","renderHtml","isSpaMode2","baseServerHandoff","entryContext","handleDocumentRequestFunction","errorForSecondRender","unwrapResponse","state2","error2","queryRoute","handleQueryRouteResult","handleQueryRouteError","errorResponseToJson","newError","errorResponse","contentType","test","text","flash","createSession","initialData","Map","flashName","unset","isSession","createSessionStorage","cookieArg","createData","readData","updateData","deleteData","warnOnceAboutSigningSessionCookie","getSession","commitSession","session","destroySession","createCookieSessionStorage","serializedCookie","_session","createMemorySessionStorage","Math","random","substring","param","questionMark","isRequired","React4","encoder2","trailer","injectRSCPayload","rscStream","decoder","resolveFlightDataPromise","flightDataPromise","Promise","resolve","startedRSC","buffered","timeout","flushBufferedChunks","chunk","buf","decode","TransformStream","transform","writeRSCStream","catch","then","flush","fatal","read","done","writeChunk","base64","fromCodePoint","releaseLock","remaining","escapeScript","script","React3","RSCRouterGlobalErrorBoundary","constructor","props","getDerivedStateFromError","getDerivedStateFromProps","render","RSCDefaultRootErrorBoundaryImpl","renderAppShell","ErrorWrapper","title","lang","charSet","content","style","fontFamily","padding","heyDeveloper","dangerouslySetInnerHTML","__html","fontSize","errorInstance","errorString","background","color","overflow","RSCDefaultRootErrorBoundary","hasRootLayout","createRSCRouteModules","payload","populateRSCRouteModules","Array","isArray","noopComponent","REACT_USE","useImpl","useSafe","promise","routeRSCServerRequest","fetchServer","createFromReadableStream","renderHTML","isDataRequest","isReactServerRequest","respondWithRSCPayload","isManifestRequest","serverResponse","detectRedirectResponse","clone","serverResponseB","buffer","streamControllers","createStream","pipeThrough","c","deepestRenderedBoundaryId","getPayload","payloadPromise","defineProperties","_deepestRenderedBoundaryId","boundaryId","formState","type","html","body2","reason","RSCStaticRouter","Location","patchedLoaderData","hydrateFallbackElement","pathnameBase","clientAction","reduceRight","previous","element","errorElement","frameworkContext","deserializeErrors","internal","ErrorConstructor","window","getHydrationData","getRouteInfo","initialMatches","routeInfo","hasHydrateFallback"],"sources":["D:/F1Demo (2)/NewProject/f1-pitwall-react/node_modules/react-router/dist/development/chunk-JG3XND5A.mjs"],"sourcesContent":["/**\n * react-router v7.9.5\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport {\n  ENABLE_DEV_WARNINGS,\n  ErrorResponseImpl,\n  FrameworkContext,\n  NO_BODY_STATUS_CODES,\n  Outlet,\n  RSCRouterContext,\n  RemixErrorBoundary,\n  RouterContextProvider,\n  RouterProvider,\n  SINGLE_FETCH_REDIRECT_STATUS,\n  SingleFetchRedirectSymbol,\n  StaticRouterProvider,\n  StreamTransfer,\n  convertRoutesToDataRoutes,\n  createMemoryRouter,\n  createServerRoutes,\n  createStaticHandler,\n  createStaticRouter,\n  decodeViaTurboStream,\n  encode,\n  escapeHtml,\n  getManifestPath,\n  getStaticContextFromError,\n  instrumentHandler,\n  isDataWithResponseInit,\n  isRedirectResponse,\n  isRedirectStatusCode,\n  isResponse,\n  isRouteErrorResponse,\n  matchRoutes,\n  redirect,\n  redirectDocument,\n  replace,\n  shouldHydrateRouteLoader,\n  stripBasename,\n  useRouteError,\n  warnOnce,\n  withComponentProps,\n  withErrorBoundaryProps,\n  withHydrateFallbackProps\n} from \"./chunk-UIGDSWPH.mjs\";\n\n// lib/dom/ssr/server.tsx\nimport * as React from \"react\";\nfunction ServerRouter({\n  context,\n  url,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n  let routes = createServerRoutes(\n    manifest.routes,\n    routeModules,\n    context.future,\n    context.isSpaMode\n  );\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    if (route && manifestRoute && shouldHydrateRouteLoader(\n      routeId,\n      route.clientLoader,\n      manifestRoute.hasLoader,\n      context.isSpaMode\n    ) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      delete context.staticHandlerContext.loaderData[routeId];\n    }\n  }\n  let router = createStaticRouter(routes, context.staticHandlerContext);\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(\n    FrameworkContext.Provider,\n    {\n      value: {\n        manifest,\n        routeModules,\n        criticalCss,\n        serverHandoffString,\n        future: context.future,\n        ssr: context.ssr,\n        isSpaMode: context.isSpaMode,\n        routeDiscovery: context.routeDiscovery,\n        serializeError: context.serializeError,\n        renderMeta: context.renderMeta\n      }\n    },\n    /* @__PURE__ */ React.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ React.createElement(\n      StaticRouterProvider,\n      {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n      }\n    ))\n  ), context.serverHandoffStream ? /* @__PURE__ */ React.createElement(React.Suspense, null, /* @__PURE__ */ React.createElement(\n    StreamTransfer,\n    {\n      context,\n      identifier: 0,\n      reader: context.serverHandoffStream.getReader(),\n      textDecoder: new TextDecoder(),\n      nonce\n    }\n  )) : null);\n}\n\n// lib/dom/ssr/routes-test-stub.tsx\nimport * as React2 from \"react\";\nfunction createRoutesStub(routes, _context) {\n  return function RoutesTestStub({\n    initialEntries,\n    initialIndex,\n    hydrationData,\n    future\n  }) {\n    let routerRef = React2.useRef();\n    let frameworkContextRef = React2.useRef();\n    if (routerRef.current == null) {\n      frameworkContextRef.current = {\n        future: {\n          unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n          v8_middleware: future?.v8_middleware === true\n        },\n        manifest: {\n          routes: {},\n          entry: { imports: [], module: \"\" },\n          url: \"\",\n          version: \"\"\n        },\n        routeModules: {},\n        ssr: false,\n        isSpaMode: false,\n        routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" }\n      };\n      let patched = processRoutes(\n        // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n        // types compared to `AgnosticRouteObject`\n        convertRoutesToDataRoutes(routes, (r) => r),\n        _context !== void 0 ? _context : future?.v8_middleware ? new RouterContextProvider() : {},\n        frameworkContextRef.current.manifest,\n        frameworkContextRef.current.routeModules\n      );\n      routerRef.current = createMemoryRouter(patched, {\n        initialEntries,\n        initialIndex,\n        hydrationData\n      });\n    }\n    return /* @__PURE__ */ React2.createElement(FrameworkContext.Provider, { value: frameworkContextRef.current }, /* @__PURE__ */ React2.createElement(RouterProvider, { router: routerRef.current }));\n  };\n}\nfunction processRoutes(routes, context, manifest, routeModules, parentId) {\n  return routes.map((route) => {\n    if (!route.id) {\n      throw new Error(\n        \"Expected a route.id in react-router processRoutes() function\"\n      );\n    }\n    let newRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      Component: route.Component ? withComponentProps(route.Component) : void 0,\n      HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n      ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n      action: route.action ? (args) => route.action({ ...args, context }) : void 0,\n      loader: route.loader ? (args) => route.loader({ ...args, context }) : void 0,\n      middleware: route.middleware ? route.middleware.map(\n        (mw) => (...args) => mw(\n          { ...args[0], context },\n          args[1]\n        )\n      ) : void 0,\n      handle: route.handle,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    let entryRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      parentId,\n      hasAction: route.action != null,\n      hasLoader: route.loader != null,\n      // When testing routes, you should be stubbing loader/action/middleware,\n      // not trying to re-implement the full loader/clientLoader/SSR/hydration\n      // flow. That is better tested via E2E tests.\n      hasClientAction: false,\n      hasClientLoader: false,\n      hasClientMiddleware: false,\n      hasErrorBoundary: route.ErrorBoundary != null,\n      // any need for these?\n      module: \"build/stub-path-to-module.js\",\n      clientActionModule: void 0,\n      clientLoaderModule: void 0,\n      clientMiddlewareModule: void 0,\n      hydrateFallbackModule: void 0\n    };\n    manifest.routes[newRoute.id] = entryRoute;\n    routeModules[route.id] = {\n      default: newRoute.Component || Outlet,\n      ErrorBoundary: newRoute.ErrorBoundary || void 0,\n      handle: route.handle,\n      links: route.links,\n      meta: route.meta,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    if (route.children) {\n      newRoute.children = processRoutes(\n        route.children,\n        context,\n        manifest,\n        routeModules,\n        newRoute.id\n      );\n    }\n    return newRoute;\n  });\n}\n\n// lib/server-runtime/cookies.ts\nimport { parse, serialize } from \"cookie\";\n\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret) => {\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"sign\"]);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    \"\"\n  );\n  return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret) => {\n  let index = cookie.lastIndexOf(\".\");\n  let value = cookie.slice(0, index);\n  let hash = cookie.slice(index + 1);\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"verify\"]);\n  try {\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n  } catch (error) {\n    return false;\n  }\n};\nvar createKey = async (secret, usages) => crypto.subtle.importKey(\n  \"raw\",\n  encoder.encode(secret),\n  { name: \"HMAC\", hash: \"SHA-256\" },\n  false,\n  usages\n);\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {}) => {\n  let { secrets = [], ...options } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = parse(cookieHeader, { ...options, ...parseOptions });\n      if (name in cookies) {\n        let value = cookies[name];\n        if (typeof value === \"string\" && value !== \"\") {\n          let decoded = await decodeCookieValue(value, secrets);\n          return decoded;\n        } else {\n          return \"\";\n        }\n      } else {\n        return null;\n      }\n    },\n    async serialize(value, serializeOptions) {\n      return serialize(\n        name,\n        value === \"\" ? \"\" : await encodeCookieValue(value, secrets),\n        {\n          ...options,\n          ...serializeOptions\n        }\n      );\n    }\n  };\n};\nvar isCookie = (object) => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnOnce(\n    !expires,\n    `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`\n  );\n}\n\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    let route = manifest[routeId];\n    if (route) {\n      memo[routeId] = route.module;\n    }\n    return memo;\n  }, {});\n}\n\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2) => {\n  ServerMode2[\"Development\"] = \"development\";\n  ServerMode2[\"Production\"] = \"production\";\n  ServerMode2[\"Test\"] = \"test\";\n  return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n  return value === \"development\" /* Development */ || value === \"production\" /* Production */ || value === \"test\" /* Test */;\n}\n\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== \"development\" /* Development */) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = void 0;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });\n  }, {});\n}\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n  let matches = matchRoutes(\n    routes,\n    pathname,\n    basename\n  );\n  if (!matches) return null;\n  return matches.map((match) => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n  let result = await handler({\n    request: stripRoutesParam(stripIndexParam(args.request)),\n    params: args.params,\n    context: args.context,\n    unstable_pattern: args.unstable_pattern\n  });\n  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n    throw new Response(null, result.init);\n  }\n  return result;\n}\nfunction stripIndexParam(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_routes\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\n// lib/server-runtime/invariant.ts\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\n      \"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\"\n    );\n    throw new Error(message);\n  }\n}\n\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n  if (typeof process !== \"undefined\") {\n    try {\n      if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n        return request.headers.get(headerName);\n      }\n    } catch (e) {\n    }\n  }\n  return null;\n}\n\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      middleware: route.module.middleware,\n      // Need to use RR's version in the param typed here to permit the optional\n      // context even though we know it'll always be provided in remix\n      loader: route.module.loader ? async (args) => {\n        let preRenderedData = getBuildTimeHeader(\n          args.request,\n          \"X-React-Router-Prerender-Data\"\n        );\n        if (preRenderedData != null) {\n          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n          invariant(encoded, \"Missing prerendered data for route\");\n          let uint8array = new TextEncoder().encode(encoded);\n          let stream = new ReadableStream({\n            start(controller) {\n              controller.enqueue(uint8array);\n              controller.close();\n            }\n          });\n          let decoded = await decodeViaTurboStream(stream, global);\n          let data2 = decoded.value;\n          if (data2 && SingleFetchRedirectSymbol in data2) {\n            let result = data2[SingleFetchRedirectSymbol];\n            let init = { status: result.status };\n            if (result.reload) {\n              throw redirectDocument(result.redirect, init);\n            } else if (result.replace) {\n              throw replace(result.redirect, init);\n            } else {\n              throw redirect(result.redirect, init);\n            }\n          } else {\n            invariant(\n              data2 && route.id in data2,\n              \"Unable to decode prerendered data\"\n            );\n            let result = data2[route.id];\n            invariant(\n              \"data\" in result,\n              \"Unable to process prerendered data\"\n            );\n            return result.data;\n          }\n        }\n        let val = await callRouteHandler(route.module.loader, args);\n        return val;\n      } : void 0,\n      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(\n        manifest,\n        future,\n        route.id,\n        routesByParentId\n      ),\n      ...commonRoute\n    };\n  });\n}\n\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n  return escapeHtml(JSON.stringify(serverHandoff));\n}\n\n// lib/server-runtime/headers.ts\nimport { splitCookiesString } from \"set-cookie-parser\";\nfunction getDocumentHeaders(context, build) {\n  return getDocumentHeadersImpl(context, (m) => {\n    let route = build.routes[m.route.id];\n    invariant(route, `Route with id \"${m.route.id}\" not found in build`);\n    return route.module.headers;\n  });\n}\nfunction getDocumentHeadersImpl(context, getRouteHeadersFn, _defaultHeaders) {\n  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n    context.matches.slice(boundaryIdx).some((match) => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  const defaultHeaders = new Headers(_defaultHeaders);\n  return matches.reduce((parentHeaders, match, idx) => {\n    let { id } = match.route;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n    let headersFn = getRouteHeadersFn(match);\n    if (headersFn == null) {\n      let headers2 = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers2);\n      }\n      prependCookies(actionHeaders, headers2);\n      prependCookies(loaderHeaders, headers2);\n      return headers2;\n    }\n    let headers = new Headers(\n      typeof headersFn === \"function\" ? headersFn({\n        loaderHeaders,\n        parentHeaders,\n        actionHeaders,\n        errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n      }) : headersFn\n    );\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers(defaultHeaders));\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = splitCookiesString(parentSetCookieString);\n    let childCookies = new Set(childHeaders.getSetCookie());\n    cookies.forEach((cookie) => {\n      if (!childCookies.has(cookie)) {\n        childHeaders.append(\"Set-Cookie\", cookie);\n      }\n    });\n  }\n}\n\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n  ...NO_BODY_STATUS_CODES,\n  304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...request.body ? { duplex: \"half\" } : void 0\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      skipRevalidation: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return isResponse(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let singleFetchResult;\n    if (context.errors) {\n      singleFetchResult = { error: Object.values(context.errors)[0] };\n    } else {\n      singleFetchResult = {\n        data: Object.values(context.actionData || {})[0]\n      };\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: singleFetchResult,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n  let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      filterMatchesToLoad: (m) => !loadRouteIds || loadRouteIds.has(m.route.id),\n      skipLoaderErrorBubbling: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return isResponse(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let results = {};\n    let loadedMatches = new Set(\n      context.matches.filter(\n        (m) => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null\n      ).map((m) => m.route.id)\n    );\n    if (context.errors) {\n      for (let [id, error] of Object.entries(context.errors)) {\n        results[id] = { error };\n      }\n    }\n    for (let [id, data2] of Object.entries(context.loaderData)) {\n      if (!(id in results) && loadedMatches.has(id)) {\n        results[id] = { data: data2 };\n      }\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: results,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, {\n  result,\n  headers,\n  status\n}) {\n  let resultHeaders = new Headers(headers);\n  resultHeaders.set(\"X-Remix-Response\", \"yes\");\n  if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n    return new Response(null, { status, headers: resultHeaders });\n  }\n  resultHeaders.set(\"Content-Type\", \"text/x-script\");\n  resultHeaders.delete(\"Content-Length\");\n  return new Response(\n    encodeViaTurboStream(\n      result,\n      request.signal,\n      build.entry.module.streamTimeout,\n      serverMode\n    ),\n    {\n      status: status || 200,\n      headers: resultHeaders\n    }\n  );\n}\nfunction generateSingleFetchRedirectResponse(redirectResponse, request, build, serverMode) {\n  let redirect2 = getSingleFetchRedirect(\n    redirectResponse.status,\n    redirectResponse.headers,\n    build.basename\n  );\n  let headers = new Headers(redirectResponse.headers);\n  headers.delete(\"Location\");\n  headers.set(\"Content-Type\", \"text/x-script\");\n  return generateSingleFetchResponse(request, build, serverMode, {\n    result: request.method === \"GET\" ? { [SingleFetchRedirectSymbol]: redirect2 } : redirect2,\n    headers,\n    status: SINGLE_FETCH_REDIRECT_STATUS\n  });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n  let redirect2 = headers.get(\"Location\");\n  if (basename) {\n    redirect2 = stripBasename(redirect2, basename) || redirect2;\n  }\n  return {\n    redirect: redirect2,\n    status,\n    revalidate: (\n      // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n      // detail of ?_data requests as our way to tell the front end to revalidate when\n      // we didn't have a response body to include that information in.\n      // With single fetch, we tell the front end via this revalidate boolean field.\n      // However, we're respecting it for now because it may be something folks have\n      // used in their own responses\n      // TODO(v3): Consider removing or making this official public API\n      headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\")\n    ),\n    reload: headers.has(\"X-Remix-Reload-Document\"),\n    replace: headers.has(\"X-Remix-Replace\")\n  };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  let timeoutId = setTimeout(\n    () => controller.abort(new Error(\"Server Timeout\")),\n    typeof streamTimeout === \"number\" ? streamTimeout : 4950\n  );\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return encode(data2, {\n    signal: controller.signal,\n    plugins: [\n      (value) => {\n        if (value instanceof Error) {\n          let { name, message, stack } = serverMode === \"production\" /* Production */ ? sanitizeError(value, serverMode) : value;\n          return [\"SanitizedError\", name, message, stack];\n        }\n        if (value instanceof ErrorResponseImpl) {\n          let { data: data3, status, statusText } = value;\n          return [\"ErrorResponse\", data3, status, statusText];\n        }\n        if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n          return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n        }\n      }\n    ],\n    postPlugins: [\n      (value) => {\n        if (!value) return;\n        if (typeof value !== \"object\") return;\n        return [\n          \"SingleFetchClassInstance\",\n          Object.fromEntries(Object.entries(value))\n        ];\n      },\n      () => [\"SingleFetchFallback\"]\n    ]\n  });\n}\n\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n  let routes = createRoutes(build.routes);\n  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */;\n  let staticHandler = createStaticHandler(dataRoutes, {\n    basename: build.basename,\n    unstable_instrumentations: build.entry.module.unstable_instrumentations\n  });\n  let errorHandler = build.entry.module.handleError || ((error, { request }) => {\n    if (serverMode !== \"test\" /* Test */ && !request.signal.aborted) {\n      console.error(\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        isRouteErrorResponse(error) && error.error ? error.error : error\n      );\n    }\n  });\n  let requestHandler = async (request, initialContext) => {\n    let params = {};\n    let loadContext;\n    let handleError = (error) => {\n      if (mode === \"development\" /* Development */) {\n        getDevServerHooks()?.processRequestError?.(error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params,\n        request\n      });\n    };\n    if (build.future.v8_middleware) {\n      if (initialContext && !(initialContext instanceof RouterContextProvider)) {\n        let error = new Error(\n          \"Invalid `context` value provided to `handleRequest`. When middleware is enabled you must return an instance of `RouterContextProvider` from your `getLoadContext` function.\"\n        );\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n      }\n      loadContext = initialContext || new RouterContextProvider();\n    } else {\n      loadContext = initialContext || {};\n    }\n    let url = new URL(request.url);\n    let normalizedBasename = build.basename || \"/\";\n    let normalizedPath = url.pathname;\n    if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n      normalizedPath = normalizedBasename;\n    } else if (normalizedPath.endsWith(\".data\")) {\n      normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n    }\n    if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n      normalizedPath = normalizedPath.slice(0, -1);\n    }\n    let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n    if (!build.ssr) {\n      let decodedPath = decodeURI(normalizedPath);\n      if (normalizedBasename !== \"/\") {\n        let strippedPath = stripBasename(decodedPath, normalizedBasename);\n        if (strippedPath == null) {\n          errorHandler(\n            new ErrorResponseImpl(\n              404,\n              \"Not Found\",\n              `Refusing to prerender the \\`${decodedPath}\\` path because it does not start with the basename \\`${normalizedBasename}\\``\n            ),\n            {\n              context: loadContext,\n              params,\n              request\n            }\n          );\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        }\n        decodedPath = strippedPath;\n      }\n      if (build.prerender.length === 0) {\n        isSpaMode = true;\n      } else if (!build.prerender.includes(decodedPath) && !build.prerender.includes(decodedPath + \"/\")) {\n        if (url.pathname.endsWith(\".data\")) {\n          errorHandler(\n            new ErrorResponseImpl(\n              404,\n              \"Not Found\",\n              `Refusing to SSR the path \\`${decodedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`\n            ),\n            {\n              context: loadContext,\n              params,\n              request\n            }\n          );\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        } else {\n          isSpaMode = true;\n        }\n      }\n    }\n    let manifestUrl = getManifestPath(\n      build.routeDiscovery.manifestPath,\n      normalizedBasename\n    );\n    if (url.pathname === manifestUrl) {\n      try {\n        let res = await handleManifestRequest(build, routes, url);\n        return res;\n      } catch (e) {\n        handleError(e);\n        return new Response(\"Unknown Server Error\", { status: 500 });\n      }\n    }\n    let matches = matchServerRoutes(routes, normalizedPath, build.basename);\n    if (matches && matches.length > 0) {\n      Object.assign(params, matches[0].params);\n    }\n    let response;\n    if (url.pathname.endsWith(\".data\")) {\n      let handlerUrl = new URL(request.url);\n      handlerUrl.pathname = normalizedPath;\n      let singleFetchMatches = matchServerRoutes(\n        routes,\n        handlerUrl.pathname,\n        build.basename\n      );\n      response = await handleSingleFetchRequest(\n        serverMode,\n        build,\n        staticHandler,\n        request,\n        handlerUrl,\n        loadContext,\n        handleError\n      );\n      if (isRedirectResponse(response)) {\n        response = generateSingleFetchRedirectResponse(\n          response,\n          request,\n          build,\n          serverMode\n        );\n      }\n      if (build.entry.module.handleDataRequest) {\n        response = await build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: singleFetchMatches ? singleFetchMatches[0].params : {},\n          request\n        });\n        if (isRedirectResponse(response)) {\n          response = generateSingleFetchRedirectResponse(\n            response,\n            request,\n            build,\n            serverMode\n          );\n        }\n      }\n    } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequest(\n        serverMode,\n        build,\n        staticHandler,\n        matches.slice(-1)[0].route.id,\n        request,\n        loadContext,\n        handleError\n      );\n    } else {\n      let { pathname } = url;\n      let criticalCss = void 0;\n      if (build.unstable_getCriticalCss) {\n        criticalCss = await build.unstable_getCriticalCss({ pathname });\n      } else if (mode === \"development\" /* Development */ && getDevServerHooks()?.getCriticalCss) {\n        criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n      }\n      response = await handleDocumentRequest(\n        serverMode,\n        build,\n        staticHandler,\n        request,\n        loadContext,\n        handleError,\n        isSpaMode,\n        criticalCss\n      );\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n  if (build.entry.module.unstable_instrumentations) {\n    requestHandler = instrumentHandler(\n      requestHandler,\n      build.entry.module.unstable_instrumentations.map((i) => i.handler).filter(Boolean)\n    );\n  }\n  return {\n    routes,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler,\n    requestHandler\n  };\n}\nvar createRequestHandler = (build, mode) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  let _requestHandler;\n  return async function requestHandler(request, initialContext) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n      _requestHandler = derived.requestHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler || !_requestHandler) {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n      _requestHandler = derived.requestHandler;\n    }\n    return _requestHandler(request, initialContext);\n  };\n};\nasync function handleManifestRequest(build, routes, url) {\n  if (build.assets.version !== url.searchParams.get(\"version\")) {\n    return new Response(null, {\n      status: 204,\n      headers: {\n        \"X-Remix-Reload-Document\": \"true\"\n      }\n    });\n  }\n  let patches = {};\n  if (url.searchParams.has(\"paths\")) {\n    let paths = /* @__PURE__ */ new Set();\n    let pathParam = url.searchParams.get(\"paths\") || \"\";\n    let requestedPaths = pathParam.split(\",\").filter(Boolean);\n    requestedPaths.forEach((path) => {\n      if (!path.startsWith(\"/\")) {\n        path = `/${path}`;\n      }\n      let segments = path.split(\"/\").slice(1);\n      segments.forEach((_, i) => {\n        let partialPath = segments.slice(0, i + 1).join(\"/\");\n        paths.add(`/${partialPath}`);\n      });\n    });\n    for (let path of paths) {\n      let matches = matchServerRoutes(routes, path, build.basename);\n      if (matches) {\n        for (let match of matches) {\n          let routeId = match.route.id;\n          let route = build.assets.routes[routeId];\n          if (route) {\n            patches[routeId] = route;\n          }\n        }\n      }\n    }\n    return Response.json(patches, {\n      headers: {\n        \"Cache-Control\": \"public, max-age=31536000, immutable\"\n      }\n    });\n  }\n  return new Response(\"Invalid Request\", { status: 400 });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let response = request.method !== \"GET\" ? await singleFetchAction(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  ) : await singleFetchLoaders(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  );\n  return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n  try {\n    let result = await staticHandler.query(request, {\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(request);\n          if (!isResponse(innerResult)) {\n            innerResult = await renderHtml(innerResult, isSpaMode);\n          }\n          return innerResult;\n        } catch (error) {\n          handleError(error);\n          return new Response(null, { status: 500 });\n        }\n      } : void 0\n    });\n    if (!isResponse(result)) {\n      result = await renderHtml(result, isSpaMode);\n    }\n    return result;\n  } catch (error) {\n    handleError(error);\n    return new Response(null, { status: 500 });\n  }\n  async function renderHtml(context, isSpaMode2) {\n    let headers = getDocumentHeaders(context, build);\n    if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let state = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors, serverMode)\n    };\n    let baseServerHandoff = {\n      basename: build.basename,\n      future: build.future,\n      routeDiscovery: build.routeDiscovery,\n      ssr: build.ssr,\n      isSpaMode: isSpaMode2\n    };\n    let entryContext = {\n      manifest: build.assets,\n      routeModules: createEntryRouteModules(build.routes),\n      staticHandlerContext: context,\n      criticalCss,\n      serverHandoffString: createServerHandoffString({\n        ...baseServerHandoff,\n        criticalCss\n      }),\n      serverHandoffStream: encodeViaTurboStream(\n        state,\n        request.signal,\n        build.entry.module.streamTimeout,\n        serverMode\n      ),\n      renderMeta: {},\n      future: build.future,\n      ssr: build.ssr,\n      routeDiscovery: build.routeDiscovery,\n      isSpaMode: isSpaMode2,\n      serializeError: (err) => serializeError(err, serverMode)\n    };\n    let handleDocumentRequestFunction = build.entry.module.default;\n    try {\n      return await handleDocumentRequestFunction(\n        request,\n        context.statusCode,\n        headers,\n        entryContext,\n        loadContext\n      );\n    } catch (error) {\n      handleError(error);\n      let errorForSecondRender = error;\n      if (isResponse(error)) {\n        try {\n          let data2 = await unwrapResponse(error);\n          errorForSecondRender = new ErrorResponseImpl(\n            error.status,\n            error.statusText,\n            data2\n          );\n        } catch (e) {\n        }\n      }\n      context = getStaticContextFromError(\n        staticHandler.dataRoutes,\n        context,\n        errorForSecondRender\n      );\n      if (context.errors) {\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let state2 = {\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: serializeErrors(context.errors, serverMode)\n      };\n      entryContext = {\n        ...entryContext,\n        staticHandlerContext: context,\n        serverHandoffString: createServerHandoffString(baseServerHandoff),\n        serverHandoffStream: encodeViaTurboStream(\n          state2,\n          request.signal,\n          build.entry.module.streamTimeout,\n          serverMode\n        ),\n        renderMeta: {}\n      };\n      try {\n        return await handleDocumentRequestFunction(\n          request,\n          context.statusCode,\n          headers,\n          entryContext,\n          loadContext\n        );\n      } catch (error2) {\n        handleError(error2);\n        return returnLastResortErrorResponse(error2, serverMode);\n      }\n    }\n  }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let result = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (queryRoute) => {\n        try {\n          let innerResult = await queryRoute(request);\n          return handleQueryRouteResult(innerResult);\n        } catch (error) {\n          return handleQueryRouteError(error);\n        }\n      } : void 0\n    });\n    return handleQueryRouteResult(result);\n  } catch (error) {\n    return handleQueryRouteError(error);\n  }\n  function handleQueryRouteResult(result) {\n    if (isResponse(result)) {\n      return result;\n    }\n    if (typeof result === \"string\") {\n      return new Response(result);\n    }\n    return Response.json(result);\n  }\n  function handleQueryRouteError(error) {\n    if (isResponse(error)) {\n      return error;\n    }\n    if (isRouteErrorResponse(error)) {\n      handleError(error);\n      return errorResponseToJson(error, serverMode);\n    }\n    if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n      let newError = new Error(\n        \"Expected a Response to be returned from resource route handler\"\n      );\n      handleError(newError);\n      return returnLastResortErrorResponse(newError, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return Response.json(\n    serializeError(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      errorResponse.error || new Error(\"Unexpected Server Error\"),\n      serverMode\n    ),\n    {\n      status: errorResponse.status,\n      statusText: errorResponse.statusText\n    }\n  );\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== \"production\" /* Production */) {\n    message += `\n\n${String(error)}`;\n  }\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\nfunction unwrapResponse(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nvar isSession = (object) => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && await cookie.parse(cookieHeader, options);\n      let data2 = id && await readData(id);\n      return createSession(data2 || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let { id, data: data2 } = session;\n      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data2, expires);\n      } else {\n        id = await createData(data2, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`\n  );\n}\n\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(\n        cookieHeader && await cookie.parse(cookieHeader, options) || {}\n      );\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\n          \"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length\n        );\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\n\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n  let map = /* @__PURE__ */ new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data2, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, { data: data2, expires });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let { data: data2, expires } = map.get(id);\n        if (!expires || expires > /* @__PURE__ */ new Date()) {\n          return data2;\n        }\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data2, expires) {\n      map.set(id, { data: data2, expires });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n}\n\n// lib/href.ts\nfunction href(path, ...args) {\n  let params = args[0];\n  let result = path.replace(/\\/*\\*?$/, \"\").replace(\n    /\\/:([\\w-]+)(\\?)?/g,\n    // same regex as in .\\router\\utils.ts: compilePath().\n    (_, param, questionMark) => {\n      const isRequired = questionMark === void 0;\n      const value = params ? params[param] : void 0;\n      if (isRequired && value === void 0) {\n        throw new Error(\n          `Path '${path}' requires param '${param}' but it was not provided`\n        );\n      }\n      return value === void 0 ? \"\" : \"/\" + value;\n    }\n  );\n  if (path.endsWith(\"*\")) {\n    const value = params ? params[\"*\"] : void 0;\n    if (value !== void 0) {\n      result += \"/\" + value;\n    }\n  }\n  return result || \"/\";\n}\n\n// lib/rsc/server.ssr.tsx\nimport * as React4 from \"react\";\n\n// lib/rsc/html-stream/server.ts\nvar encoder2 = new TextEncoder();\nvar trailer = \"</body></html>\";\nfunction injectRSCPayload(rscStream) {\n  let decoder = new TextDecoder();\n  let resolveFlightDataPromise;\n  let flightDataPromise = new Promise(\n    (resolve) => resolveFlightDataPromise = resolve\n  );\n  let startedRSC = false;\n  let buffered = [];\n  let timeout = null;\n  function flushBufferedChunks(controller) {\n    for (let chunk of buffered) {\n      let buf = decoder.decode(chunk, { stream: true });\n      if (buf.endsWith(trailer)) {\n        buf = buf.slice(0, -trailer.length);\n      }\n      controller.enqueue(encoder2.encode(buf));\n    }\n    buffered.length = 0;\n    timeout = null;\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      buffered.push(chunk);\n      if (timeout) {\n        return;\n      }\n      timeout = setTimeout(async () => {\n        flushBufferedChunks(controller);\n        if (!startedRSC) {\n          startedRSC = true;\n          writeRSCStream(rscStream, controller).catch((err) => controller.error(err)).then(resolveFlightDataPromise);\n        }\n      }, 0);\n    },\n    async flush(controller) {\n      await flightDataPromise;\n      if (timeout) {\n        clearTimeout(timeout);\n        flushBufferedChunks(controller);\n      }\n      controller.enqueue(encoder2.encode(\"</body></html>\"));\n    }\n  });\n}\nasync function writeRSCStream(rscStream, controller) {\n  let decoder = new TextDecoder(\"utf-8\", { fatal: true });\n  const reader = rscStream.getReader();\n  try {\n    let read;\n    while ((read = await reader.read()) && !read.done) {\n      const chunk = read.value;\n      try {\n        writeChunk(\n          JSON.stringify(decoder.decode(chunk, { stream: true })),\n          controller\n        );\n      } catch (err) {\n        let base64 = JSON.stringify(btoa(String.fromCodePoint(...chunk)));\n        writeChunk(\n          `Uint8Array.from(atob(${base64}), m => m.codePointAt(0))`,\n          controller\n        );\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  let remaining = decoder.decode();\n  if (remaining.length) {\n    writeChunk(JSON.stringify(remaining), controller);\n  }\n}\nfunction writeChunk(chunk, controller) {\n  controller.enqueue(\n    encoder2.encode(\n      `<script>${escapeScript(\n        `(self.__FLIGHT_DATA||=[]).push(${chunk})`\n      )}</script>`\n    )\n  );\n}\nfunction escapeScript(script) {\n  return script.replace(/<!--/g, \"<\\\\!--\").replace(/<\\/(script)/gi, \"</\\\\$1\");\n}\n\n// lib/rsc/errorBoundaries.tsx\nimport React3 from \"react\";\nvar RSCRouterGlobalErrorBoundary = class extends React3.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: null, location: props.location };\n    }\n    return { error: state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ React3.createElement(\n        RSCDefaultRootErrorBoundaryImpl,\n        {\n          error: this.state.error,\n          renderAppShell: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction ErrorWrapper({\n  renderAppShell,\n  title,\n  children\n}) {\n  if (!renderAppShell) {\n    return children;\n  }\n  return /* @__PURE__ */ React3.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ React3.createElement(\"head\", null, /* @__PURE__ */ React3.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ React3.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ React3.createElement(\"title\", null, title)), /* @__PURE__ */ React3.createElement(\"body\", null, /* @__PURE__ */ React3.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children)));\n}\nfunction RSCDefaultRootErrorBoundaryImpl({\n  error,\n  renderAppShell\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ React3.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */ React3.createElement(\n      ErrorWrapper,\n      {\n        renderAppShell,\n        title: \"Unhandled Thrown Response!\"\n      },\n      /* @__PURE__ */ React3.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText),\n      ENABLE_DEV_WARNINGS ? heyDeveloper : null\n    );\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ React3.createElement(ErrorWrapper, { renderAppShell, title: \"Application Error!\" }, /* @__PURE__ */ React3.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"), /* @__PURE__ */ React3.createElement(\n    \"pre\",\n    {\n      style: {\n        padding: \"2rem\",\n        background: \"hsla(10, 50%, 50%, 0.1)\",\n        color: \"red\",\n        overflow: \"auto\"\n      }\n    },\n    errorInstance.stack\n  ), heyDeveloper);\n}\nfunction RSCDefaultRootErrorBoundary({\n  hasRootLayout\n}) {\n  let error = useRouteError();\n  if (hasRootLayout === void 0) {\n    throw new Error(\"Missing 'hasRootLayout' prop\");\n  }\n  return /* @__PURE__ */ React3.createElement(\n    RSCDefaultRootErrorBoundaryImpl,\n    {\n      renderAppShell: !hasRootLayout,\n      error\n    }\n  );\n}\n\n// lib/rsc/route-modules.ts\nfunction createRSCRouteModules(payload) {\n  const routeModules = {};\n  for (const match of payload.matches) {\n    populateRSCRouteModules(routeModules, match);\n  }\n  return routeModules;\n}\nfunction populateRSCRouteModules(routeModules, matches) {\n  matches = Array.isArray(matches) ? matches : [matches];\n  for (const match of matches) {\n    routeModules[match.id] = {\n      links: match.links,\n      meta: match.meta,\n      default: noopComponent\n    };\n  }\n}\nvar noopComponent = () => null;\n\n// lib/rsc/server.ssr.tsx\nvar REACT_USE = \"use\";\nvar useImpl = React4[REACT_USE];\nfunction useSafe(promise) {\n  if (useImpl) {\n    return useImpl(promise);\n  }\n  throw new Error(\"React Router v7 requires React 19+ for RSC features.\");\n}\nasync function routeRSCServerRequest({\n  request,\n  fetchServer,\n  createFromReadableStream,\n  renderHTML,\n  hydrate = true\n}) {\n  const url = new URL(request.url);\n  const isDataRequest = isReactServerRequest(url);\n  const respondWithRSCPayload = isDataRequest || isManifestRequest(url) || request.headers.has(\"rsc-action-id\");\n  const serverResponse = await fetchServer(request);\n  if (respondWithRSCPayload || serverResponse.headers.get(\"React-Router-Resource\") === \"true\") {\n    return serverResponse;\n  }\n  if (!serverResponse.body) {\n    throw new Error(\"Missing body in server response\");\n  }\n  const detectRedirectResponse = serverResponse.clone();\n  let serverResponseB = null;\n  if (hydrate) {\n    serverResponseB = serverResponse.clone();\n  }\n  const body = serverResponse.body;\n  let buffer;\n  let streamControllers = [];\n  const createStream = () => {\n    if (!buffer) {\n      buffer = [];\n      return body.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            buffer.push(chunk);\n            controller.enqueue(chunk);\n            streamControllers.forEach((c) => c.enqueue(chunk));\n          },\n          flush() {\n            streamControllers.forEach((c) => c.close());\n            streamControllers = [];\n          }\n        })\n      );\n    }\n    return new ReadableStream({\n      start(controller) {\n        buffer.forEach((chunk) => controller.enqueue(chunk));\n        streamControllers.push(controller);\n      }\n    });\n  };\n  let deepestRenderedBoundaryId = null;\n  const getPayload = () => {\n    const payloadPromise = Promise.resolve(\n      createFromReadableStream(createStream())\n    );\n    return Object.defineProperties(payloadPromise, {\n      _deepestRenderedBoundaryId: {\n        get() {\n          return deepestRenderedBoundaryId;\n        },\n        set(boundaryId) {\n          deepestRenderedBoundaryId = boundaryId;\n        }\n      },\n      formState: {\n        get() {\n          return payloadPromise.then(\n            (payload) => payload.type === \"render\" ? payload.formState : void 0\n          );\n        }\n      }\n    });\n  };\n  try {\n    if (!detectRedirectResponse.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const payload = await createFromReadableStream(\n      detectRedirectResponse.body\n    );\n    if (serverResponse.status === SINGLE_FETCH_REDIRECT_STATUS && payload.type === \"redirect\") {\n      const headers2 = new Headers(serverResponse.headers);\n      headers2.delete(\"Content-Encoding\");\n      headers2.delete(\"Content-Length\");\n      headers2.delete(\"Content-Type\");\n      headers2.delete(\"X-Remix-Response\");\n      headers2.set(\"Location\", payload.location);\n      return new Response(serverResponseB?.body || \"\", {\n        headers: headers2,\n        status: payload.status,\n        statusText: serverResponse.statusText\n      });\n    }\n    const html = await renderHTML(getPayload);\n    const headers = new Headers(serverResponse.headers);\n    headers.set(\"Content-Type\", \"text/html; charset=utf-8\");\n    if (!hydrate) {\n      return new Response(html, {\n        status: serverResponse.status,\n        headers\n      });\n    }\n    if (!serverResponseB?.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n    return new Response(body2, {\n      status: serverResponse.status,\n      headers\n    });\n  } catch (reason) {\n    if (reason instanceof Response) {\n      return reason;\n    }\n    try {\n      const status = isRouteErrorResponse(reason) ? reason.status : 500;\n      const html = await renderHTML(() => {\n        const decoded = Promise.resolve(\n          createFromReadableStream(createStream())\n        );\n        const payloadPromise = decoded.then(\n          (payload) => Object.assign(payload, {\n            status,\n            errors: deepestRenderedBoundaryId ? {\n              [deepestRenderedBoundaryId]: reason\n            } : {}\n          })\n        );\n        return Object.defineProperties(payloadPromise, {\n          _deepestRenderedBoundaryId: {\n            get() {\n              return deepestRenderedBoundaryId;\n            },\n            set(boundaryId) {\n              deepestRenderedBoundaryId = boundaryId;\n            }\n          },\n          formState: {\n            get() {\n              return payloadPromise.then(\n                (payload) => payload.type === \"render\" ? payload.formState : void 0\n              );\n            }\n          }\n        });\n      });\n      const headers = new Headers(serverResponse.headers);\n      headers.set(\"Content-Type\", \"text/html\");\n      if (!hydrate) {\n        return new Response(html, {\n          status,\n          headers\n        });\n      }\n      if (!serverResponseB?.body) {\n        throw new Error(\"Failed to clone server response\");\n      }\n      const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n      return new Response(body2, {\n        status,\n        headers\n      });\n    } catch {\n    }\n    throw reason;\n  }\n}\nfunction RSCStaticRouter({ getPayload }) {\n  const decoded = getPayload();\n  const payload = useSafe(decoded);\n  if (payload.type === \"redirect\") {\n    throw new Response(null, {\n      status: payload.status,\n      headers: {\n        Location: payload.location\n      }\n    });\n  }\n  if (payload.type !== \"render\") return null;\n  let patchedLoaderData = { ...payload.loaderData };\n  for (const match of payload.matches) {\n    if (shouldHydrateRouteLoader(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    ) && (match.hydrateFallbackElement || !match.hasLoader)) {\n      delete patchedLoaderData[match.id];\n    }\n  }\n  const context = {\n    get _deepestRenderedBoundaryId() {\n      return decoded._deepestRenderedBoundaryId ?? null;\n    },\n    set _deepestRenderedBoundaryId(boundaryId) {\n      decoded._deepestRenderedBoundaryId = boundaryId;\n    },\n    actionData: payload.actionData,\n    actionHeaders: {},\n    basename: payload.basename,\n    errors: payload.errors,\n    loaderData: patchedLoaderData,\n    loaderHeaders: {},\n    location: payload.location,\n    statusCode: 200,\n    matches: payload.matches.map((match) => ({\n      params: match.params,\n      pathname: match.pathname,\n      pathnameBase: match.pathnameBase,\n      route: {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        handle: match.handle,\n        hasErrorBoundary: match.hasErrorBoundary,\n        loader: match.hasLoader || !!match.clientLoader,\n        index: match.index,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      }\n    }))\n  };\n  const router = createStaticRouter(\n    payload.matches.reduceRight((previous, match) => {\n      const route = {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        element: match.element,\n        errorElement: match.errorElement,\n        handle: match.handle,\n        hasErrorBoundary: !!match.errorElement,\n        hydrateFallbackElement: match.hydrateFallbackElement,\n        index: match.index,\n        loader: match.hasLoader || !!match.clientLoader,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      };\n      if (previous.length > 0) {\n        route.children = previous;\n      }\n      return [route];\n    }, []),\n    context\n  );\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules: createRSCRouteModules(payload)\n  };\n  return /* @__PURE__ */ React4.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React4.createElement(RSCRouterGlobalErrorBoundary, { location: payload.location }, /* @__PURE__ */ React4.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React4.createElement(\n    StaticRouterProvider,\n    {\n      context,\n      router,\n      hydrate: false,\n      nonce: payload.nonce\n    }\n  ))));\n}\nfunction isReactServerRequest(url) {\n  return url.pathname.endsWith(\".rsc\");\n}\nfunction isManifestRequest(url) {\n  return url.pathname.endsWith(\".manifest\");\n}\n\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData({\n  state,\n  routes,\n  getRouteInfo,\n  location,\n  basename,\n  isSpaMode\n}) {\n  let hydrationData = {\n    ...state,\n    loaderData: { ...state.loaderData }\n  };\n  let initialMatches = matchRoutes(routes, location, basename);\n  if (initialMatches) {\n    for (let match of initialMatches) {\n      let routeId = match.route.id;\n      let routeInfo = getRouteInfo(routeId);\n      if (shouldHydrateRouteLoader(\n        routeId,\n        routeInfo.clientLoader,\n        routeInfo.hasLoader,\n        isSpaMode\n      ) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n        delete hydrationData.loaderData[routeId];\n      } else if (!routeInfo.hasLoader) {\n        hydrationData.loaderData[routeId] = null;\n      }\n    }\n  }\n  return hydrationData;\n}\n\nexport {\n  ServerRouter,\n  createRoutesStub,\n  createCookie,\n  isCookie,\n  ServerMode,\n  setDevServerHooks,\n  createRequestHandler,\n  createSession,\n  isSession,\n  createSessionStorage,\n  createCookieSessionStorage,\n  createMemorySessionStorage,\n  href,\n  RSCRouterGlobalErrorBoundary,\n  RSCDefaultRootErrorBoundary,\n  populateRSCRouteModules,\n  routeRSCServerRequest,\n  RSCStaticRouter,\n  deserializeErrors,\n  getHydrationData\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}